//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHPathNode.h"
#include "../LevelHelperLoader.h"
#include "LHSettings.h"
#include "LHSprite.h"
//#include "platform.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//int LHPathNode::numberOfPathNodes = 0;
LHPathNode::LHPathNode(std::vector<CCPoint> points, LHSprite* spr){
        
    speed = 2.2f;
    interval = 0.01f;
    paused = false;
    startAtEndPoint = false;
    isCyclic = false;
    restartOtherEnd = false;
    axisOrientation = 0;
    
    flipX = false;
    flipY = false;
    sprite = spr;
    pathPoints = std::vector<CCPoint>(points);
    
    currentPoint = 0;
    elapsed = 0.0f;
    isLine = true;
    
    initialAngle = sprite->getRotation();
    
    if(pathPoints.size() > 0)
        prevPathPosition = pathPoints[0];
}
LHPathNode::~LHPathNode(void){
    //CCLog("PATH NODE DEALLOC");
}


void LHPathNode::restart(){
    currentPoint = 0;
    elapsed = 0.0f;
}
void LHPathNode::update(float dt)
{
//    CCLog("UPDATE PATH1");
    if(LHSettings::sharedInstance()->levelPaused())return;
	if(!sprite)return;
	if(paused) return;	
	if(pathPoints.size() == 0)return;

//    CCLog("UPDATE PATH2");
    bool killSelf = false;
    
	CCPoint startPosition = pathPoints[currentPoint];
    
	int previousPoint = currentPoint -1;
	if(previousPoint < 0){
		previousPoint = 0;
	}
	
	CCPoint prevPosition = pathPoints[previousPoint];
	CCPoint endPosition = startPosition;
	
	float startAngle = LHPathNode::rotationDegreeFromPoint(startPosition,prevPosition);
	if(currentPoint == 0)
		startAngle = initialAngle+270;
        
        float endAngle = startAngle;
        
        if((currentPoint + 1) < (int)pathPoints.size())
        {
            endPosition = pathPoints[currentPoint+1];
            endAngle = LHPathNode::rotationDegreeFromPoint(endPosition,startPosition);
        }
        else {
            if(isCyclic){
                if(!restartOtherEnd)
                    std::reverse(pathPoints.begin(),pathPoints.end());

                if(flipX)sprite->setFlipX(!sprite->isFlipX());
                if(flipY)sprite->setFlipY(!sprite->isFlipY());
                currentPoint = -1;
            }
            
#if COCOS2D_VERSION >= 0x00020000
//
//            
            CCNotificationCenter::sharedNotificationCenter()->postNotification(LHPathMovementHasEndedNotification, sprite);
//            cocos2d::extension::CCNotificationCenter::sharedNotificationCenter()->postNotification(LHPathMovementHasEndedNotification, sprite);
#else
            CCNotificationCenter::sharedNotifCenter()->postNotification(LHPathMovementHasEndedNotification, sprite);
#endif       

            if(!isCyclic)
                killSelf = true;
                }
	
	if(axisOrientation == 1)
		startAngle += 90.0f;
        if(axisOrientation == 1)
            endAngle += 90.0f;
            
            if(startAngle > 360)
                startAngle -=360;
                if(endAngle > 360)
                    endAngle-=360;
                    
                    
                    float t = MIN(1.0f, (float)elapsed/interval);
                    
                    CCPoint deltaP = ccpSub( endPosition, startPosition );
                    
                    CCPoint newPos = ccp((startPosition.x + deltaP.x * t), 
                                         (startPosition.y + deltaP.y * t));
                    
                    
                    if(startAngle > 270 && startAngle < 360 &&
                       endAngle > 0 && endAngle < 90){
                        startAngle -= 360;
                    }
	
	if(startAngle > 0 && startAngle < 90 &&
	   endAngle < 360 && endAngle > 270){
		startAngle += 360;
	}
	
	float deltaA = endAngle - startAngle;
	float newAngle = startAngle + deltaA*t;
    
	if(newAngle > 360)
		newAngle -= 360;
        
        if(NULL != sprite)
        {
            CCPoint sprPos = sprite->getPosition();
            
            CCPoint sprDelta = CCPointMake(newPos.x - prevPathPosition.x, newPos.y - prevPathPosition.y);
            
            if(relativeMovement)
                sprite->transformPosition(ccp((sprPos.x + sprDelta.x), 
                                              (sprPos.y + sprDelta.y)));
            else {
                sprite->transformPosition(newPos);
            }
            
            prevPathPosition = newPos;        
        }
    
	if(axisOrientation != 0){
		sprite->transformRotation(newAngle);
    }
	if(isLine){
        if(axisOrientation != 0){    
            sprite->transformRotation(endAngle);
        }
    }
	
	
	float dist = ccpDistance(prevPathPosition, endPosition);
	
	if(0.001 > dist)
	{
		if(currentPoint + 1 < (int)pathPoints.size())
		{
			elapsed = 0;
			currentPoint += 1;    
            
#if COCOS2D_VERSION >= 0x00020000
            CCNotificationCenter::sharedNotificationCenter()->postNotification(LHPathMovementHasChangedPointNotification, sprite);
//            cocos2d::extension::CCNotificationCenter::sharedNotificationCenter()->postNotification(LHPathMovementHasChangedPointNotification, sprite);
#else
            CCNotificationCenter::sharedNotifCenter()->postNotification(LHPathMovementHasChangedPointNotification, sprite);
#endif       

		}
	}
    
	/////////////////////////////////////////
    
	elapsed += dt;
    
    if(killSelf)
        sprite->stopPathMovement();
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setSpeed(float value){
    speed = value;
    interval = speed/(pathPoints.size()-1);
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setStartAtEndPoint(bool val){
    
    startAtEndPoint = val;
    
    if(startAtEndPoint)
		std::reverse(pathPoints.begin(),pathPoints.end());
}
////////////////////////////////////////////////////////////////////////////////
float LHPathNode::rotationDegreeFromPoint(CCPoint endPoint, CCPoint startPoint)
{
	float rotateDegree = atan2(fabs(endPoint.x-startPoint.x),
							   fabs(endPoint.y-startPoint.y)) * 180.0f / M_PI;
	if (endPoint.y>=startPoint.y)
	{
		if (endPoint.x>=startPoint.x){
			rotateDegree = 180.0f + rotateDegree;
		}
		else{
			rotateDegree = 180.0f - rotateDegree;
		}
	}
	else{
		if (endPoint.x<=startPoint.x){
		}
		else{
			rotateDegree = 360.0 - rotateDegree;
		}
	}
	return rotateDegree;
}
////////////////////////////////////////////////////////////////////////////////
